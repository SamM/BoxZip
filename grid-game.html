<html>

<head>
    <title>SquareGate - 2D Grid Navigating Game</title>
    <script src="seedrandom.js" type="text/javascript"></script>
    <script src="BoxZip.js" type="text/javascript"></script>
    <script type="text/javascript">

        let NUM_GATES = 30;
        let NUM_WORLDS = 10;

        const MAX_GATES = 100;
        const MAX_WORLDS = 16;

        const MIN_LOCATION = 32;
        const MAX_LOCATION = 1024;

        const DRAW_DEPTH = 2;

        const COLOR_THRESHOLD = 0.2;

        let seed;

        let scene;

        let size;

        let position = [];

        let prevPositions = [];
        let prevWorlds = [];

        let this_world = 0;
        let target_world = 0;
        
        let worlds = [];

        let points = 0;

        let steps = 0;

        let inputSets = ['45120 ', 'qwaszx ', 'erdfcv ', 'tyghbn ', 'uijkm, ', 'opl;./ '];
        let lastInput = 0;

        let colors_used = [];
        let locations_used = [];

        function RandomWorld(justIndex){
            if(justIndex) return Math.floor(Math.random()*worlds.length);
            return worlds[Math.floor(Math.random()*worlds.length)];
        }

        function RandomColor(alpha){
            if(alpha === undefined) alpha = 1;
            function randomize(){
                return BoxZip.Color(Math.random(), Math.random(), Math.random());
            }
            let color = randomize();

            function match(used){
                let diff = color.difference(used);
                return diff <= COLOR_THRESHOLD;
            }
            
            while(colors_used.filter(match).length > 0){
                color = randomize();
            }
            colors_used.push(color);
            return color;
        }
        function RandomLocation(world){
            function randomize(){
                return MIN_LOCATION+Math.floor(Math.random()*(MAX_LOCATION-MIN_LOCATION));
            }
            let location = randomize();
            while(locations_used.indexOf(location) > -1){
                location = randomize();
            }
            locations_used.push(location);
            return location;
        }

        function World(i, color){
            this.id = i;
            this.color = color ? color : RandomColor();
            this.contents = [];
            this.add =  function(gate) { this.contents.push(gate); };
            this.drawTo = function(canvas, position, offset, depth) {
                depth = typeof depth == 'number' && depth >= 0 ? depth : DRAW_DEPTH;
                if(depth === 0) return;
                this.contents.forEach((gate)=>gate.drawTo.call(gate, canvas, position, offset, depth));
            };
        }
        

        function Gate(place, world){
            this.location = place;
            this.world = world;
        }
        Gate.prototype.drawTo = function(canvas, position, offset, depth){
            let area = BoxZip[2](this.location);
            let zoom_path = BoxZip[2](position).toPath();
            let area_path = area.toPath();
            let offset_path = BoxZip[2](offset).toPath();
            area_path = offset_path.concat(area_path);
            if(!BoxZip.PathsMatch(area_path, zoom_path)) return;

            depth = typeof depth == 'number' && depth >= 0 ? depth : DRAW_DEPTH;
            if(depth === 0) return;
            depth--;

            area_path = BoxZip.minus(area_path, zoom_path);
            area = BoxZip[2](area_path).toArea();

            let s = size;

            let x = area[0][0];
            let w = area[0][1] - x;
            let y = area[1][0];
            let h = area[1][1] - y;

            let ctx = canvas.getContext('2d');

            ctx.fillStyle = this.world.color.toString();
            ctx.fillRect(x*s,y*s,w*s,h*s);

            new_offset = BoxZip[2](this.location).toPath().concat(offset_path);
            if(depth > 0) this.world.drawTo(canvas, position, new_offset, depth);
        }

        

        function PopulateWorlds(steps){
            if(typeof steps != 'number') return;
            if(steps <= 0) return;

            let gate = new Gate(RandomLocation(), RandomWorld());

            let world = RandomWorld();
            world.add(gate);

            PopulateWorlds(steps-1);
        }

        function resizeCanvas(){
            size = Math.min(window.innerHeight, window.innerWidth) * 1;
            scene.width = size;
            scene.height = size;
            let ctx = scene.getContext('2d');
            ctx.fillStyle = worlds[this_world].color.toString();
            ctx.fillRect(0,0,size,size);
            document.body.style.backgroundColor = worlds[target_world].color.toString();
        }

        function toVariable(str){
            if(str.toLowerCase() === 'true') return true;
            if(str.toLowerCase() === 'false') return false;
            if(str.indexOf(/[^0-9\.\+\-]/g) > -1) return str;
            let num = parseFloat(str);
            if(isNaN(num)) return str;
            else return num;
        }

        function getQuery(){
            let query = location.href.split('?');
            let out = {};
            if(query.length == 1) return out;
            query = query[1].split('&').forEach(function(str){
                str = str.split('=');
                if(str.length==1) out[str.toLowerCase()] = true;
                else out[str[0].toLowerCase()] = toVariable(str.slice(1).join('='))
            });
            return out;
        }

        function nextTarget(){
            while(target_world == this_world) target_world = RandomWorld(true);
        }

        function BuildInitialPath(){
            for(var i = 0, next; i < worlds.length; i++){
                next = (i + 1) % worlds.length;
                worlds[i].add(new Gate(RandomLocation(worlds[i]), worlds[next]));
            }
        }

        function sceneClick(e){
            if(paused) return;
            var rect = e.target.getBoundingClientRect();
            var x = e.clientX - rect.left; //x position within the element.
            var y = e.clientY - rect.top;  //y position within the element.
            let location = 0;
            if(x >= scene.width / 2) location += 1;
            if(y >= scene.height / 2) location += 2;
            ZoomIn(location);
            if (e.stopPropagation) e.stopPropagation()
            else e.cancelBubble=true;
            return false;
        }

        function backgroundClick(){
            if(paused) return;
            ZoomOut();
        }

        let paused = false;

        /*/
        ///
        ///     Start Function
        ///
        /*/
        function start(){
            scene = document.getElementById('scene');
            let query = getQuery();
            
           if(query.seed !== undefined) seed = query.seed;

            Math.seedrandom(seed);

            NUM_WORLDS = 3 + Math.floor(Math.random()*(MAX_WORLDS-3));
            NUM_GATES = 3 + Math.floor(Math.random()*(MAX_GATES-3));

            for(var i=0; i<NUM_WORLDS; i++){
                worlds.push(new World(i));
            }

            nextTarget();

            scene.addEventListener('click', sceneClick);
            window.addEventListener('click', backgroundClick);

            window.onfocus = function() {
                paused = true;
                setTimeout(function(){ paused = false; }, 10);
            }
            
            resizeCanvas();
            createKeyHints();
            BuildInitialPath();
            PopulateWorlds(NUM_GATES);
            worlds[this_world].drawTo(scene, position);
        }

        let keyHints = {};

        function createKeyHints(){
            
        }

        function updateKeyHints(){
            
        }

        function update(){
            resizeCanvas();
            updateKeyHints()
            document.getElementById('score').innerText = points;
            document.getElementById('steps').innerText = steps;
            worlds[this_world].drawTo(scene, position);
        }

        function updateInputSet(char){
            for(var i=0; i< inputSets.length; i++){
                if(inputSets[i].indexOf(char) > -1) {
                    lastInput = i;
                    return i;
                }
            }
            return -1;
        }

        function ZoomOut(){
            if(position.length > 0){
                position.splice(-1,1);
                steps++;
            }else if(prevWorlds.length > 0){
                position = prevPositions.shift();
                position.splice(-1,1);
                this_world = prevWorlds.shift();
                if(this_world == target_world){
                    points++;
                    nextTarget();
                }
                steps++;
            }
            update();
        }

        function ZoomIn(direction){
            position.push(direction);
            let pos_path = BoxZip[2](position).toPath();
            let matches = worlds[this_world].contents.filter(function(gate){
                let gate_path = BoxZip[2](gate.location).toPath();
                return (pos_path.length === gate_path.length && BoxZip.PathsMatch(pos_path, gate_path))
            });
            if(matches.length > 0){
                prevPositions.unshift(position);
                prevWorlds.unshift(this_world);
                this_world = matches[0].world.id;
                position = [];
                if(this_world == target_world){
                    points++;
                    nextTarget();
                }
            }
            steps++;
            update();
        }

        function controller(event){
            if(event.defaultPrevented) return;
            var handled = false;
            var direction = -1;
            var key;
            if(event.key !== undefined){
                key = event.key;
            }else if(event.keyCode !== undefined){
                key = event.keyCode
            }
            key = key+"";

            if('qetuo4'.indexOf(key) > -1) direction = 0;
            if('wryip5'.indexOf(key) > -1) direction = 1;
            if('1adgjl'.indexOf(key) > -1) direction = 2;
            if('2sfhk;'.indexOf(key) > -1) direction = 3;

            if('0zxcvbnm,./ '.indexOf(key) > -1){
                ZoomOut();
                handled = true; 
            }

            if(direction !== -1 && !handled) {
                ZoomIn(direction);
                handled = true;
            }

            if(handled){
                updateInputSet(key);
                event.preventDefault();
            }
        }

        window.addEventListener('load', start);
        window.addEventListener('resize', update);
        window.addEventListener('keypress', controller);
        

    </script>
    <style>
        .side-panel {
            position: absolute;
            width: 100%;
            text-align: center;
            -webkit-user-select: none; /* Safari */        
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE10+/Edge */
            user-select: none; /* Standard */
            pointer-events: none;
            opacity: 0.75;
        }
        .side-panel * {
            display: inline-block;
            padding: 0 5px;
            margin: 1.25vh 0;
            font-size: 5vh;
        }
        html, body{
            padding: 0;
            margin: 0;
            text-align: center;
            font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
            position: relative;
        }
        .bottom{
            bottom: 0;
        }
        .logo, .black, .label{
            color: black;
        }
        .logo span, .white, .label span{
            color: white;
        }
    </style>
</head>

<body>
    <div class="side-panel">
        <h1 class="logo">Square<span>Gate</span></h1>
    </div>
    
    <canvas id="scene" width=100 height=100></canvas>
    
    <div class="side-panel bottom">
        <h1 class="score label">Score: <span id="score">0</span></h1>
        <h1 class="steps label">Steps: <span id="steps">0</span></h1>
    </div>

</body>

</html>