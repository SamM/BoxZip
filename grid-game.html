<html>

<head>
    <title>ZoomRoom - 2D Grid Navigating Game</title>
    <link rel="stylesheet" href="Game.css">
    <script src="Random.js" type="text/javascript"></script>
    <script src="seedrandom.js" type="text/javascript"></script>
    <script src="BoxZip.js" type="text/javascript"></script>
    <script type="text/javascript">

        let NUM_GATES = 30;
        let NUM_WORLDS = 10;

        let ANIMATE = true;

        const DEFAULT_BG_COLOR = "#202020";

        const MAX_GATES = 100;
        const MAX_WORLDS = 10;

        const MIN_LOCATION = 4;
        const MAX_LOCATION = 64;

        const DRAW_DEPTH = 10;

        const COLOR_THRESHOLD = 0.24;

        const WORLD_IMAGE_SIZE = 1024*2*2;

        const IMAGE_UPDATE_ITERATIONS = 6;

        const ANIMATION_STEPS = 12;

        const BORDER_WIDTH = "2vh";

        let seed;

        let scene;

        let size;

        let position = [];

        let last_animation = new Animation(0,[],[],0, null);
        let animations_forward = [];
        let animation_i = 0;

        let animation_step = 0;

        let prevPositions = [];
        let prevWorlds = [];

        let this_world = 0;
        let target_world = 0;
        
        let worlds = [];

        let travel_depth = 0;
        let points = 0;
        let steps = 0;

        let inputSets = ['45120 ', 'qwaszx ', 'erdfcv ', 'tyghbn ', 'uijkm, ', 'opl;./ '];
        let lastInput = 0;

        let colors_used = [];
        let locations_used = [];

        function getQuery(){
            let query = location.href.split('?');
            let out = {};
            if(query.length == 1) return out;
            query = query[1].split('&').forEach(function(str){
                str = str.split('=');
                if(str.length==1) out[str.toLowerCase()] = true;
                else out[str[0].toLowerCase()] = toVariable(str.slice(1).join('='))
            });
            return out;
        }

        let query = getQuery();

        function JumpToSeed(seed){
            query.seed = seed;
            location.href = location.href.split('?')[0] + "?" + Object.keys(query).map((param)=>param+"="+query[param]).join('&');
        }
        function RandomSeed(){
            let seed = RandomWord(2 + Math.floor(Math.random()*2), Math.random()>0.5);
            if(Math.random()>0.5) seed += Math.floor(Math.random()*100000);
            if(Math.random()>0.85) seed += "!";
            return seed;
        }
        if(Object.keys(query).indexOf('seed')===-1){
            JumpToSeed(RandomSeed());
        }

        function RandomWorld(justIndex){
            if(justIndex) return Math.floor(Math.random()*worlds.length);
            return worlds[Math.floor(Math.random()*worlds.length)];
        }

        function RandomColor(alpha){
            if(alpha === undefined) alpha = 1;
            function randomize(){
                return BoxZip.Color(Math.random(), Math.random(), Math.random());
            }
            let color = randomize();

            function match(used){
                let diff = color.difference(used);
                return diff <= COLOR_THRESHOLD;
            }
            
            while(colors_used.filter(match).length > 0){
                color = randomize();
            }
            colors_used.push(color);
            return color;
        }
        function RandomLocation(world){
            let locations_used = Array.isArray(world) ? world : typeof world == 'object' && Array.isArray(world.destinations) ? world.destinations : [];
            function randomize(){
                return MIN_LOCATION+Math.floor(Math.random()*(MAX_LOCATION-MIN_LOCATION));
            }
            let location = randomize();
            function getIntersects(location1){
                let path1 = BoxZip[2](location1).toPath();
                return locations_used.filter((location2)=>{
                    if(location2 === location1) return true;
                    let path2 = BoxZip[2](location2).toPath();
                    let same = 0;
                    let ideal = Math.min(path2.length, path1.length);
                    for(let i=0; i<ideal; i++){
                        if(path1[i] === path2[i]) same++;
                    }
                    return same === ideal;
                }).length
            }
            
            let intersects = getIntersects(location);
            let tries = 500;
            while(intersects > 0){
                location = randomize();
                intersects = getIntersects(location);
                tries--;
                if(intersects > 0 && tries <= 0) return 0;
            }
            locations_used.push(location);
            return location;
        }

        function World(i, color){
            this.id = i;
            this.color = color ? color : RandomColor();
            this.contents = [];
            this.add =  function(gate) { this.contents.push(gate); };
            this.drawTo = function(canvas, position, offset, step, from_position) {
                let zoom_path = BoxZip[2](position).toPath();
                let offset_path = BoxZip[2](offset).toPath();
                let from_path = BoxZip[2](from_position).toPath();
                step = typeof step == 'number' ? step : 0;

                let zoom_area = BoxZip[2](zoom_path).toArea();
                let offset_area = BoxZip[2](offset_path).toArea();
                let from_area = BoxZip[2](from_path).toArea();

                let ss = WORLD_IMAGE_SIZE;
                let ds = canvas.width;
                let p = (1/ANIMATION_STEPS)*step;

                let sx = zoom_area[0][0];
                let sw = zoom_area[0][1] - sx;
                let sy = zoom_area[1][0];
                let sh = zoom_area[1][1] - sy;

                let dx = offset_area[0][0];
                let dw = offset_area[0][1] - dx;
                let dy = offset_area[1][0];
                let dh = offset_area[1][1] - dy;

                //console.log(position, from_position);

                sx = (p*zoom_area[0][0])+((1-p)*from_area[0][0]);
                sw = (p*zoom_area[0][1])+((1-p)*from_area[0][1]) - sx;
                sy = (p*zoom_area[1][0])+((1-p)*from_area[1][0]);
                sh = (p*zoom_area[1][1])+((1-p)*from_area[1][1]) - sy;

                let ctx = canvas.getContext('2d');

                ctx.drawImage(this.canvas, sx*s,sy*s,sw*s,sh*s, dx*ds, dy*ds, dw*ds, dh*ds);
            };
            this.update = function(){
                let canvas = this.canvas;
                let ctx = canvas.getContext('2d');
                let s = WORLD_IMAGE_SIZE;
                ctx.fillStyle = this.color.toString();
                ctx.fillRect(0,0,s,s);
                this.contents.forEach((gate)=>gate.drawTo.call(gate, canvas));
            }

            // World Image
            this.canvas = document.createElement('canvas');
            let s = WORLD_IMAGE_SIZE;
            this.canvas.height = this.canvas.width = s;
            let ctx = this.canvas.getContext('2d');
            ctx.fillStyle = this.color.toString();
            ctx.fillRect(0,0,s,s);

            this.destinations = [];
        }
        

        function Gate(place, world){
            this.location = place;
            this.world = world;
        }
        Gate.prototype.drawTo = function(canvas, position){
            this.world.drawTo(canvas, position, this.location);
        }

        function clearCanvas(){
            let ctx = scene.getContext("2d");
            ctx.clearRect(0,0,scene.width,scene.height);
        }

        function update(){
            resizeCanvas();
            clearCanvas();

            if(animations_forward.length > animation_i){
                // Animating
                let animation = animations_forward[animation_i] || last_animation;
                worlds[animation.world_from].drawTo(scene, animation.position_to, [], animation_step, animation.position_from);
                animation_step++;
                if(animation_step >= ANIMATION_STEPS){
                    animation_step = 0;
                    last_animation = animations_forward[animation_i];
                    if(animation.world_out !== null){
                        document.body.style.backgroundColor = worlds[animation.world_out].color.toString();
                    }else{
                        document.body.style.backgroundColor = DEFAULT_BG_COLOR;
                    }
                    animation_i++;
                    console.log('animation step', last_animation)
                }
            }else{
                // Static - Viewing Level
                //console.log('lol')
                animations_forward = [];
                animation_i = 0;
                let animation = last_animation;
                worlds[animation.world_to].drawTo(scene, animation.position_end, [], animation_step, animation.position_end);
            }
            
            if(ANIMATE) window.requestAnimationFrame(update);
        }        

        function PopulateWorlds(steps){
            if(typeof steps != 'number') return;
            if(steps <= 0) return;

            let world = RandomWorld();
            let world2 = RandomWorld();
            let location = RandomLocation(world2);

            if(location !== 0){
                let gate = new Gate(location, world);
                world2.add(gate);
            }

            PopulateWorlds(steps-1);
        }

        function resizeCanvas(){
            size = window.innerHeight * 0.6;
            if(window.innerHeight >= window.innerWidth * 1.6) size = window.innerWidth * 0.8;
            scene.width = size;
            scene.height = size;
            let ctx = scene.getContext('2d');
            ctx.fillStyle = worlds[this_world].color.toString();
            ctx.fillRect(0,0,size,size);
        }

        function toVariable(str){
            if(str.toLowerCase() === 'true') return true;
            if(str.toLowerCase() === 'false') return false;
            if(str.indexOf(/[^0-9\.\+\-]/g) > -1) return str;
            let num = parseFloat(str);
            if(isNaN(num)) return str;
            else return num;
        }

        function nextTarget(){
            while(target_world == this_world) target_world = RandomWorld(true);
            let color = worlds[target_world].color.toString();
            scene.style.border = color + " "+BORDER_WIDTH+" solid";
            scene.style.backgroundColor = color;
        }

        function BuildInitialPath(){
            for(var i = 0, next; i < worlds.length; i++){
                next = (i + 1) % worlds.length;
                worlds[i].add(new Gate(RandomLocation(worlds[i]), worlds[next]));
            }
        }

        function sceneClick(e){
            //if(paused) return;
            var rect = e.target.getBoundingClientRect();
            var x = e.clientX - rect.left; //x position within the element.
            var y = e.clientY - rect.top;  //y position within the element.
            let location = 0;
            if(x >= scene.width / 2) location += 1;
            if(y >= scene.height / 2) location += 2;
            ZoomIn(location);
            if (e.stopPropagation) e.stopPropagation()
            else e.cancelBubble=true;
            return false;
        }

        function backgroundClick(){
            //if(paused) return;
            ZoomOut();
        }

        //let paused = false;

        /*/
        ///
        ///     Start Function
        ///
        /*/
        function start(){
            scene = document.getElementById('scene');
            let query = getQuery();

            document.getElementById('randomize').addEventListener("click", (e)=>{
                JumpToSeed(RandomSeed());
            });
            
           if(query.seed !== undefined) seed = query.seed;

           document.getElementById('scene').style.opacity = "100%";

            Math.seedrandom(seed);

            NUM_WORLDS = 3 + Math.floor(Math.random()*(MAX_WORLDS-3));
            NUM_GATES = 3 + Math.floor(Math.random()*(MAX_GATES-3));

            for(var i=0; i<NUM_WORLDS; i++){
                worlds.push(new World(i));
            }

            nextTarget();

            scene.addEventListener('click', sceneClick);
            window.addEventListener('click', backgroundClick);

            //window.onblur = function() { paused = true; }
            
            resizeCanvas();
            createKeyHints();
            BuildInitialPath();
            PopulateWorlds(NUM_GATES);

            // Update World Images with iterations
            for(var u=0; u < IMAGE_UPDATE_ITERATIONS; u++){
                for(var w=0; w<NUM_WORLDS; w++){
                    worlds[w].update();
                }
            }

            worlds[this_world].drawTo(scene, position);

            let color = worlds[target_world].color.toString();
            scene.style.border = color + " "+BORDER_WIDTH+" solid";
            scene.style.backgroundColor = color;

            if(ANIMATE) update();
        }

        let keyHints = {};

        function createKeyHints(){
            
        }

        function updateKeyHints(){
            
        }

        function calculateScore(points, score){
            if(score === 0) return 0;
            return Math.floor(points*points*points/score*1000);
        }

        function updateOutputs(){
            document.getElementById('score').innerText = points;
            document.getElementById('steps').innerText = steps;
            document.getElementById('depth').innerText = travel_depth;
            document.getElementById('overall').innerText = calculateScore(points, steps);
        }

        function updateInputSet(char){
            for(var i=0; i< inputSets.length; i++){
                if(inputSets[i].indexOf(char) > -1) {
                    lastInput = i;
                    return i;
                }
            }
            return -1;
        }

        function CheckIfAnimating(){
            return animation_step > 0;
        }
        function ZoomOut(){
            if(position.length == 0 && prevWorlds.length == 0) return;
            if(CheckIfAnimating()) return;
            let old_position = position.slice();
            if(position.length > 0){
                position.splice(-1,1);
                steps++;
                let world_out = prevWorlds.length > 0 ? prevWorlds[0] : null;
                animations_forward.push(new Animation(this_world, old_position, position, this_world, world_out));
            }else if(prevWorlds.length > 0){
                position = prevPositions.shift();
                old_position = position.slice();
                position.splice(-1,1);
                let old_this_world = this_world;
                this_world = prevWorlds.shift();
                let world_out = prevWorlds.length > 0 ? prevWorlds[0] : null;
                animations_forward.push(new Animation(this_world, old_position, position, this_world, world_out));
                if(this_world == target_world){
                    points++;
                    nextTarget();
                }
                steps++;
            }

            travel_depth--;
            if(travel_depth < 0) travel_depth = 0;
            updateOutputs();
            if(!ANIMATE) update();
        }

        function Animation(world_from, position_from, position_to, world_to, outter_world){
            this.world_from = world_from;
            this.position_from = position_from;
            this.position_to = position_to;
            this.world_to = world_to;
            this.position_end = world_to === world_from ? position_to : [];
            this.world_out = outter_world;
        }

        function ZoomIn(direction){
            let old_position = position.slice();
            if(CheckIfAnimating()) return;
            position.push(direction);
            //animation_worlds.push(this_world);
            let pos_path = BoxZip[2](position).toPath();
            let matches = worlds[this_world].contents.filter(function(gate){
                let gate_path = BoxZip[2](gate.location).toPath();
                return (pos_path.length === gate_path.length && BoxZip.PathsMatch(pos_path, gate_path))
            });
            
            if(matches.length > 0){
                prevPositions.unshift(position);
                prevWorlds.unshift(this_world);
                let old_this_world = this_world;
                this_world = matches[0].world.id;
                let world_out = prevWorlds.length > 0 ? prevWorlds[0] : null;
                animations_forward.push(new Animation(old_this_world, old_position, prevPositions[0], this_world, world_out));
                position = [];
                if(this_world == target_world){
                    points++;
                    nextTarget();
                }
            }else{
                let world_out = prevWorlds.length > 0 ? prevWorlds[0] : null;
                animations_forward.push(new Animation(this_world, old_position, position, this_world, world_out));
            }
            
            steps++;
            travel_depth++;
            updateOutputs();
            if(!ANIMATE) update();
        }

        function controller(event){
            if(event.defaultPrevented) return;
            var handled = false;
            var direction = -1;
            var key;
            if(event.key !== undefined){
                key = event.key;
            }else if(event.keyCode !== undefined){
                key = event.keyCode
            }
            key = key+"";

            if('qetuo4'.indexOf(key) > -1) direction = 0;
            if('wryip5'.indexOf(key) > -1) direction = 1;
            if('1adgjl'.indexOf(key) > -1) direction = 2;
            if('2sfhk;'.indexOf(key) > -1) direction = 3;

            if('0zxcvbnm,./ '.indexOf(key) > -1){
                ZoomOut();
                handled = true; 
            }

            if(direction !== -1 && !handled) {
                ZoomIn(direction);
                handled = true;
            }

            if(handled){
                updateInputSet(key);
                event.preventDefault();
            }
        }

        window.addEventListener('load', start);
        window.addEventListener('resize', update);
        window.addEventListener('keypress', controller);
        

    </script>
   
</head>

<body>
    <div class="button" id="randomize"><span>&#x27F3;</span><span>Randomize</span></div>

    <div class="side-panel top">
        <h1 class="logo"><span>Zoom</span><span class="white">Room</span></h1>
    </div>
    
    <canvas id="scene" width=100 height=100></canvas>
    
    <div class="side-panel bottom">
        <h1 class="depth label left">Depth: <span id="depth">0</span></h1>
        <h1 class="score label right">Gates: <span id="score">0</span></h1>
        <h1 class="steps label left block">Steps: <span id="steps">0</span></h1>
        <h1 class="overall label right">Score: <span id="overall">0</span></h1>
    </div>
</body>

</html>